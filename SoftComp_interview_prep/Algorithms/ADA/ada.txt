

Refer to G-Drive for recorded sessions:


SECTION - I
-----------


[COMPLETED]
What is greedy method?
Coin Change problem
Knapsack problem
Job sequencing with Deadlines problem
Dijkstra's algorithm to find the shortest distance from given source to destination
Prim's algorithm to find the minimum spanning tree
Kruskal's algorithm to find the minimum spanning tree
Huffman coding for data compression & encryption

[COMPLETED]
With the help of some c code examples please:
Big O 
Time complexity
Space complexity
Big 0, Big theta & big omega, little o notation
Best case, worstcase & expected case
Drop the constants
Drop the Non-Dominant Terms
Multi-Part Algorithms: Add vs Multiply
Amortized time
Log N Runtimes
Recursive Runtimes
Non-Recursive rumtimes


C code snippets functions logics explaination for - 
AVL Trees, red black trees,  DFS, BFS


Priority Queues and Heaps
---------------------------

7.1 What is a Priority Queue?
7.2 Priority Queue ADT
7.3 Priority Queue Applications
7.4 Priority Queue Implementations
7.5 Heaps and Binary Heaps
7.6 Binary Heaps
7.7 Heapsort
7.8 Priority Queues [Heaps]: Problems & Solutions

Divide-and-Conquer
---------------------
General Method
Binary Search
Maximum & Minimum (Divide and Conquer Method)
	Time complexity By Considering Element Comparison
	Time complexity By Considering all Comparisons
Sorting Using Divide & Conquer
	Merge Sorting
	Quick Sorting (Partition Exchange Sort)

Multiplication of Large Integers and Strassen’s Matrix Multiplication
Multiplication of Large Integers
Strassen’s Matrix Multiplication

The Closest-Pair and Convex-Hull Problems by Divide-and-Conquer
The Closest-Pair Problem
Convex-Hull Problem


Transform-and-Conquer
---------------------
Heaps & Heap Sort
Create a Heap (Bottom-Up Heap Construction)
Heap Sort Using Bottom up Approach
Tracing of Heap Sort
Analysis of Heap Sort using Bottom up Approach

Presorting

Gaussian Elimination
LU Decomposition
Computing a Matrix Inverse
Computing a Determinant

Horner’s Rule and Binary Exponentiation
Horner’s Rule
Binary Exponentiation

Problem Reduction
Computing the Least Common Multiple
Counting Paths in a Graph
Reduction of Optimization Problems
Linear Programming
Reduction to Graph Problems

Dynamic programming & memoization
---------------------------------
Multistage Graphs
	Forward approach
	Backward approach
Warshal's Algorithm (Transitive Closure) - [COMPLETED]
Floyd's Algorithm (For all Pairs Shortest Paths Problem) 
Optimal Binary search trees
The 0/1 Knapsack Problem - [COMPLETED]
Knapsack Problem using memory functions - [COMPLETED]
Bellman-Ford AlgorithmTraveling Salesman Problem(TSP) - [COMPLETED]
	TSP using brute Force - [COMPLETED]
	TSP using Dynamic Programming - [COMPLETED]
	
Limitations of Algorithm Power
---------------------------------
Introduction
Lower Bound Arguments
Decision TreesP, NP & NP-Complete Problems
Challenges of Numerical Algorithms

Coping with the Limitations of Algorithm Power
---------------------------------------------
Backtracking
	Implementation of Back tracking problems
	N-Queens Problem
	Sum of Subset Problem
	Hamiltonian Circuit Problem
Branch & Bound
	Knapsack Problem
	Assignment Problem
	Travelling Salesperson Porblem
Approximation Algorithms for NP-Hard Problems
	Approximation Algorithms for Travelling Salesman Problem(TSP)
	Approximation Algorithm for Knapsack Problem
	
Decrease & Conquer
---------------------------------
Topological Sorting
	Topological Sort Using DFS Method.
	Toplogical Sort Using Source Removal Method.

Algorithms for Generating Combinatorial Objects
Generating Permutations
Generating Subsets

Decrease-by-a-Constant-Factor Algorithms
Fake-Coin Problem
Russian Peasant Multiplication
Josephus Problem

Variable-Size-Decrease Algorithms
Computing a Median and the Selection Problem
Interpolation Search
Searching and Insertion in a Binary Search Tree
The Game of Nim


Hashing
---------------------------------

14.1 What is Hashing?
14.2 Why Hashing?
14.3 HashTable ADT
14.4 Understanding Hashing
14.5 Components of Hashing
14.6 Hash Table
14.7 Hash Function
14.8 Load Factor
14.9 Collisions
14.10 Collision Resolution Techniques
14.11 Separate Chaining
14.12 Open Addressing
14.13 Comparison of Collision Resolution Techniques
14.14 How Hashing Gets O(1) Complexity?
14.15 Hashing Techniques
14.16 Problems for which Hash Tables are not suitable
14.17 Bloom Filters
14.18 Hashing: Problems & Solutions


15. String Algorithms
---------------------------------

15.1 Introduction
15.2 String Matching Algorithms
15.3 Brute Force Method
15.4 Rabin-Karp String Matching Algorithm
15.5 String Matching with Finite Automata
15.6 KMP Algorithm
15.7 Boyer-Moore Algorithm
15.8 Data Structures for Storing Strings
15.9 Hash Tables for Strings
15.10 Binary Search Trees for Strings
15.11 Tries
15.12 Ternary Search Trees
15.13 Comparing BSTs, Tries and TSTs
15.14 Suffix Trees
15.15 String Algorithms: Problems & Solutions

Space and Time Trade-Offs
-------------------------

Sorting by Counting
Input Enhancement in String Matching
Horspool’s Algorithm
Boyer-Moore Algorithm

Disjoint Sets ADT
---------------------------------

8.1 Introduction
8.2 Equivalence Relations and Equivalence Classes
8.3 Disjoint Sets ADT
8.4 Applications
8.5 Tradeoffs in Implementing Disjoint Sets ADT
8.8 Fast UNION Implementation (Slow FIND)
8.9 Fast UNION Implementations (Quick FIND)
8.10 Summary
8.11 Disjoint Sets: Problems & Solutions

Others:

Iterative Improvement
---------------------

The Simplex Method
Geometric Interpretation of Linear Programming
An Outline of the Simplex Method 
Further Notes on the Simplex Method 

The Maximum-Flow Problem 
Maximum Matching in Bipartite Graphs
The Stable Marriage Problem

Algorithms for Solving Nonlinear Equations
Bisection Method
Method of False Position
Newton's Method

Brute Force & Exhaustive Search

Sequential Search & Brute-Force String Matching
Sequeuntial Search
Brute-Force String Matching

Closest-Pair and Convex-Hull Problems by Brute Force
Closest-Pair Problem
Convex-Hull Problem

Exhaustive Search
Traveling Salesman Problem
Knapsack Problem
Assignment Problem


-----

Graph Traversal 145
5.1 Flavors of Graphs . . . . . . . . . . . . . . . . . . . . . . . . . . . 146
5.2 Data Structures for Graphs . . . . . . . . . . . . . . . . . . . . . 151
5.3 War Story: I was a Victim ofMoore’s Law . . . . . . . . . . . . 155
5.4 War Story: Getting the Graph . . . . . . . . . . . . . . . . . . . . 158
5.5 Traversing a Graph . . . . . . . . . . . . . . . . . . . . . . . . . . 161
5.6 Breadth-First Search . . . . . . . . . . . . . . . . . . . . . . . . . 162
5.7 Applications of Breadth-First Search . . . . . . . . . . . . . . . . 166
5.8 Depth-First Search . . . . . . . . . . . . . . . . . . . . . . . . . . 169
5.9 Applications of Depth-First Search . . . . . . . . . . . . . . . . . 172
5.10 Depth-First Search on Directed Graphs . . . . . . . . . . . . . . 178
5.11 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 184

Weighted Graph Algorithms 191
6.1 Minimum Spanning Trees . . . . . . . . . . . . . . . . . . . . . . 192
6.2 War Story: Nothing but Nets . . . . . . . . . . . . . . . . . . . . 202
6.3 Shortest Paths . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 205
6.4 War Story: Dialing for Documents . . . . . . . . . . . . . . . . . 212
6.5 Network Flows and Bipartite Matching . . . . . . . . . . . . . . 217
6.6 Design Graphs, Not Algorithms . . . . . . . . . . . . . . . . . . . 222
6.7 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 225


Combinatorial Search and Heuristic Methods 230
7.1 Backtracking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 231
7.2 Search Pruning . . . . . . . . . . . . . . . . . . . . . . . . . . . . 238
7.3 Sudoku . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 239
7.4 War Story: Covering Chessboards . . . . . . . . . . . . . . . . . . 244
7.5 Heuristic SearchMethods . . . . . . . . . . . . . . . . . . . . . . 247
7.6 War Story: Only it is Not a Radio . . . . . . . . . . . . . . . . . 260
7.7 War Story: Annealing Arrays . . . . . . . . . . . . . . . . . . . . 263
7.8 Other Heuristic SearchMethods . . . . . . . . . . . . . . . . . . 266
7.9 Parallel Algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . 267
7.10 War Story: Going Nowhere Fast . . . . . . . . . . . . . . . . . . . 268
7.11 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 270


Dynamic Programming 273
8.1 Caching vs. Computation . . . . . . . . . . . . . . . . . . . . . . 274
8.2 Approximate String Matching . . . . . . . . . . . . . . . . . . . . 280
8.3 Longest Increasing Sequence . . . . . . . . . . . . . . . . . . . . . 289
8.4 War Story: Evolution of the Lobster . . . . . . . . . . . . . . . . 291
8.5 The Partition Problem . . . . . . . . . . . . . . . . . . . . . . . . 294
8.6 Parsing Context-Free Grammars . . . . . . . . . . . . . . . . . . 298
8.7 Limitations of Dynamic Programming: TSP . . . . . . . . . . . . 301
8.8 War Story: What’s Past is Prolog . . . . . . . . . . . . . . . . . . 304
8.9 War Story: Text Compression for Bar Codes . . . . . . . . . . . 307
8.10 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 310


Numerical Problems 393
13.1 Solving Linear Equations . . . . . . . . . . . . . . . . . . . . . . . 395
13.2 Bandwidth Reduction . . . . . . . . . . . . . . . . . . . . . . . . 398
13.3 Matrix Multiplication . . . . . . . . . . . . . . . . . . . . . . . . . 401
13.4 Determinants and Permanents . . . . . . . . . . . . . . . . . . . . 404
13.5 Constrained and Unconstrained Optimization . . . . . . . . . . . 407
13.6 Linear Programming . . . . . . . . . . . . . . . . . . . . . . . . . 411
13.7 Random Number Generation . . . . . . . . . . . . . . . . . . . . 415
13.8 Factoring and Primality Testing . . . . . . . . . . . . . . . . . . . 420
13.9 Arbitrary-Precision Arithmetic . . . . . . . . . . . . . . . . . . . 423
13.10 Knapsack Problem . . . . . . . . . . . . . . . . . . . . . . . . . . 427
13.11 Discrete Fourier Transform . . . . . . . . . . . . . . . . . . . . . 431

Combinatorial Problems 434
14.1 Sorting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 436
14.2 Searching . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 441
14.3 Median and Selection . . . . . . . . . . . . . . . . . . . . . . . . . 445
14.4 Generating Permutations . . . . . . . . . . . . . . . . . . . . . . . 448
14.5 Generating Subsets . . . . . . . . . . . . . . . . . . . . . . . . . . 452
14.6 Generating Partitions . . . . . . . . . . . . . . . . . . . . . . . . . 456
14.7 Generating Graphs . . . . . . . . . . . . . . . . . . . . . . . . . . 460
14.8 Calendrical Calculations . . . . . . . . . . . . . . . . . . . . . . . 465
14.9 Job Scheduling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 468
14.10 Satisfiability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 472


Graph Problems: Polynomial-Time 475
15.1 Connected Components . . . . . . . . . . . . . . . . . . . . . . . 477
15.2 Topological Sorting . . . . . . . . . . . . . . . . . . . . . . . . . . 481
15.3 Minimum Spanning Tree . . . . . . . . . . . . . . . . . . . . . . . 484
15.4 Shortest Path . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 489
15.5 Transitive Closure and Reduction . . . . . . . . . . . . . . . . . . 495
15.6 Matching . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 498
15.7 Eulerian Cycle/Chinese Postman . . . . . . . . . . . . . . . . . . 502
15.8 Edge and Vertex Connectivity . . . . . . . . . . . . . . . . . . . . 505
15.9 Network Flow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 509
15.10 Drawing Graphs Nicely . . . . . . . . . . . . . . . . . . . . . . . . 513
15.11 Drawing Trees . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 517
15.12 Planarity Detection and Embedding . . . . . . . . . . . . . . . . 520


Graph Problems: Hard Problems 523
16.1 Clique . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 525
16.2 Independent Set . . . . . . . . . . . . . . . . . . . . . . . . . . . . 528
16.3 Vertex Cover . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 530
16.4 Traveling Salesman Problem . . . . . . . . . . . . . . . . . . . . . 533
16.5 Hamiltonian Cycle . . . . . . . . . . . . . . . . . . . . . . . . . . 538
16.6 Graph Partition . . . . . . . . . . . . . . . . . . . . . . . . . . . . 541
16.7 Vertex Coloring . . . . . . . . . . . . . . . . . . . . . . . . . . . . 544
16.8 Edge Coloring . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 548
16.9 Graph Isomorphism . . . . . . . . . . . . . . . . . . . . . . . . . . 550
16.10 Steiner Tree . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 555
16.11 Feedback Edge/Vertex Set . . . . . . . . . . . . . . . . . . . . . . 559


Computational Geometry 562
17.1 Robust Geometric Primitives . . . . . . . . . . . . . . . . . . . . 564
17.2 Convex Hull . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 568
17.3 Triangulation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 572
17.4 Voronoi Diagrams . . . . . . . . . . . . . . . . . . . . . . . . . . . 576
17.5 Nearest Neighbor Search . . . . . . . . . . . . . . . . . . . . . . . 580
17.6 Range Search . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 584
17.7 Point Location . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 587
17.8 Intersection Detection . . . . . . . . . . . . . . . . . . . . . . . . 591
17.9 Bin Packing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 595
17.10 Medial-Axis Transform . . . . . . . . . . . . . . . . . . . . . . . . 598
17.11 Polygon Partitioning . . . . . . . . . . . . . . . . . . . . . . . . . 601
17.12 Simplifying Polygons . . . . . . . . . . . . . . . . . . . . . . . . . 604
17.13 Shape Similarity . . . . . . . . . . . . . . . . . . . . . . . . . . . . 607
17.14 Motion Planning . . . . . . . . . . . . . . . . . . . . . . . . . . . 610
17.15 Maintaining Line Arrangements . . . . . . . . . . . . . . . . . . . 614
17.16 Minkowski Sum . . . . . . . . . . . . . . . . . . . . . . . . . . . . 617
18 Set and String Problems 620
18.1 Set Cover . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 621
18.2 Set Packing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 625
18.3 String Matching . . . . . . . . . . . . . . . . . . . . . . . . . . . . 628
18.4 Approximate String Matching . . . . . . . . . . . . . . . . . . . . 631
18.5 Text Compression . . . . . . . . . . . . . . . . . . . . . . . . . . . 637
18.6 Cryptography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 641
18.7 Finite State Machine Minimization . . . . . . . . . . . . . . . . . 646
18.8 Longest Common Substring/Subsequence . . . . . . . . . . . . . 650
18.9 Shortest Common Superstring . . . . . . . . . . . . . . . . . . . . 654

---------------------------------

SECTION - II
-------------

https://www.geeksforgeeks.org/must-do-coding-questions-for-companies-like-amazon-microsoft-adobe/


Greedy Algorithms

Activity Selection
N meetings in one room
Coin Piles
Maximize Toys
Page Faults in LRU
Largest number possible
Minimize the heights
Minimize the sum of product
Huffman Decoding
Minimum Spanning Tree
Shop in Candy Store
Geek collects the balls

Dynamic Programming
	
Minimum Operations
Max length chain
Minimum number of Coins
Longest Common Substring
Longest Increasing Subsequence
Longest Common Subsequence
0 – 1 Knapsack Problem
Maximum sum increasing subsequence
Minimum number of jumps
Edit Distance
Coin Change Problem
Subset Sum Problem
Box Stacking
Rod Cutting
Path in Matrix
Minimum sum partition
Count number of ways to cover a distance
Egg Dropping Puzzle
Optimal Strategy for a Game
Shortest Common Supersequence
	
	
Divide and Conquer

Find the element that appears once in sorted array
Search in a Rotated Array
Binary Search
Sum of Middle Elements of two sorted arrays
Quick Sort
Merge Sort
K-th element of two sorted Arrays


Backtracking

N-Queen Problem
Solve the Sudoku
Rat in a Maze Problem
Word Boggle
Generate IP Addresses

SECTION - III
-------------
Solutions to the Algorithms_DesignKleinberg's book.

SECTION - IV
------------
Important:

Datastructure https://www.tutorialspoint.com/data_structures_algorithms/linked_list_program_in_c.htm
Algo https://www.programiz.com/dsa/stack

Travelling Salesman Problem Greedy Algo
Prim's Minimal Spanning Tree Algorithm
Kruskal's Minimal Spanning Tree Algorithm
Dijkstra's Minimal Spanning Tree Algorithm
Graph - Map Coloring
Graph - Vertex Cover
Knapsack Problem
Job Scheduling Problem
Fibonacci number series Dynamic Programming
Knapsack problem
Tower of Hanoi
All pair shortest path by Floyd-Warshall
Shortest path by Dijkstra
Project scheduling
Merge Sort Divide and Conquer
Quick Sort
Binary Search
Strassen's Matrix Multiplication
Closest pair (points)


https://www.tryexponent.com/courses/software-engineering
https://www.tryexponent.com/questions?src=nav
https://www.youtube.com/results?search_query=system+design
https://www.youtube.com/channel/UC9vLsnF6QPYuH51njmIooCQ


Misc:
Topics shared:

Strassen's Matrix Multiplication.
Recursion
Dynamic programming & memoization
Multistage Graphs
	Forward approach
	Backward approach
Warshal's Algorithm (Transitive Closure)
Floyd's Algorithm (For all Pairs Shortest Paths Problem)
Optimal Binary search trees
The 0/1 Knapsack Problem
Knapsack Problem using memory functions
Bellman-Ford AlgorithmTraveling Salesman Problem(TSP)
	TSP using brute Force
	TSP using Dynamic Programming


Completed topics:

TSP brute force and dynamic programming , Bellman Ford Algo
Knapsack problem using dynamic programming and memory functions , Warshall algo for transitive closure

	
With the help of some c code examples please:
Big O 
Time complexity
Space complexity
Big 0, Big theta & big omega, little o notation
Best case, worstcase & expected case
Drop the constants
Drop the Non-Dominant Terms
Multi-Part Algorithms: Add vs Multiply
Amortized time
Log N Runtimes
Recursive Runtimes
Non-Recursive rumtimes


What is greedy method?
Coin Change problem
Knapsack problem
Job sequencing with Deadlines problem
Dijkstra's algorithm to find the shortest distance from given source to destination
Prim's algorithm to find the minimum spanning tree
Kruskal's algorithm to find the minimum spanning tree
Huffman coding for data compression & encryption


0. Basics of graphs concepts:

A tree is  actually a type of graph, but not all graphs are trees. Simply put, a tree is a connected graph without cycles.

A graph is simply a collection of noed with edges between (some of( them.

. Graphs can be either directed (like the following graph) or undirected. While directed edges are like a one-way street, undirected egdges are like a two-way street
. The graph might consist of mulitple isolated subgraphs. if there is a path between every parit of vertices, it is called a "connected graph".
. The graph can also have cycles(or not). An "acyclic graph" is one without cycles.


1. Adjaceny List
2. Adjacency Matrices
3. Depth-First Search (DFS)
4. Breadth-First Search (BFS)
5. Bi-directional search
6. Topological sort
7. Dijkstra's algorithm
